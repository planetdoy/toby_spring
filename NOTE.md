# 강의 내용 정리

## 요구사항
- 해외직구를 위한 원화 결제 준비 기능 개발
- 주문번호, 외국 통화 종류, 외국 통화 기준 결제 금액을 전달 받아서 다음의 정보를 더해 Payment를 생성한다.
  - 적용환율
  - 원화 환산 금액
  - 원화 환산 금액 유효시간
- PaymentService.prepare() 메소드로 개발
  - Payment 오브젝트 리턴

## 개발 방법
- 빠르게 완성해서 가장 간단한 방법을 찾는다.
- 작성한 코드가 동작하는지 확인하는 방법을 찾는다.
- 조금씩 기능을 추가하고 다시 검증한다.
- 코드를 한눈에 이해하기 힘들다면 코멘트로 설명을 달아준다.
  - 3초 이내에 이해가 되지 않는다면 안티패턴일 수 있지만 이해가 되지 않는다면 달아두는게 좋고 해결하는 방법이 있다.

* Gradle
> JVM 환경에서 사용할 수 있는 범용적인 개발 도구  

* settings > gradle
> build 를 gradle 이 아닌 idea 로 변경하는게 좀더 빠르다.

* 돈 관련된 숫자 타입을 사용할 때는 BigDecimal 타입을 사용한다.

## 오브젝트와 의존관계
> 스프링에서 가장 중요한 용어들

### 오브젝트
> 오브젝트를 만들기 위해서 클래스를 작성한다.(청사진)
> 클래스의 인스턴스 = 오브젝트
> 인스턴스 - 추상적인 것(클래스)의 실체
> 자바에서는 배열(Array)도 오브젝트

### 의존관계
> 클래스 레벨의 의존관계, 런타임 레벨의 의존관계 
> Supplier 가 변경되면 Client 코드가 영향을 받는다.
> 하나의 클래스에서 다른 클래스를 사용하고 있다면 사용의존관계라고 이야기한다.

## 관심사의 분리(SoC)
> 관심사가 다른 건 분리해야한다.
> 기술적인 로직과 업무(비지니스)로직이 섞이면 코드를 이해하는데 어려움이 있을 수 있다.
> 관심사는 변경과 관련이 있다.
> 변경의 이유, 시점이 다른 코드를 같이 두는건 좋지 않다.
> 관심 분리 방법 1 - 메서드 추출
> 관심 분리 방법 2 - 클래스 추출
  > 재사용을 위해
  > 확장성을 위해
  > 상속 - 확장성 코드를 만들 때 사용할 수도 있다.
> "상속을 통한 확장"은 한계가 있다.

## 클래스의 분리 (TODO: 다시듣기)
> 상속을 통한 확장을 통해 필요한 메서드로 변경을 할 수 있었지만...

## 인터페이스의 도입
> 인터페이스를 생성하여 메서드를 선언하고 해당 메서드를 구현하는 클래스들을 작성함으로써 
> 최소한의 코드 변경으로 구현클래스를 변경할 수 있게 되었다.
> 그러나 여전히 결합도가 높은 상태이다. 여전히 비지니스 로직 클래스 파일을 수정해야하기 때문

## 관계설정 책임의 분리
> 런타임 의존관계, 코드레벨 의존관계
> 인터페이스의 도입으로 인터페이스에 의존하는 것 같지만 사실 인터페이스와 구현클래스 모두에 의존하고 있는 것 이다.
> 변경이 생기면 책임을 가진 곳도 변경이 일어나야합니다.
> 변경을 하지 않으려면 의존관계를 설정하는 부분을 분리시킨다.
> 분리방법은 변경되는 클래스 앞에 하나를 더 두고 의존관계를 전달하는 것이다.

## 오브젝트 팩토리
> 클래스 앞에서 의존관계를 전달 받았지만 전달하는 쪽(Client)에서도 
> 두가지 역할(1.의존관계 설정, 2.서비스로직 호출)을 맡게 되어 의존관계를 설정하는 클래스를 추가로 분리하였다.

## 원칙과 패턴
> 관심사의 분리로 코드를 변화를 해왔다.
> 객체지향 원칙
> 객체치향적 패턴

1. 개방 폐쇄 원칙(OCP) Open-Closed Principle
> 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다.  
> 어떤 부분은 열리고 어떤부분은 닫혀 있어야한다.  
> 정리 : 클래스의 기능을 확장할 때 클래스의 코드는 변경되면 안된다.  

2. 높은 응집도와 낮은 결합도
> 응집도가 높다는 것은 하나의 모듈이 하나의 책임 또는 관심사에 집중되어있다는 뜻.  
> 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.  

> 책임과 관심사가 다른 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.    
> 변화가 일어날 때 비용이 적게 든다.  
> 소프트웨어의 품질이 올라가고 높은 유지보수성을 가진다. 라고 이야기할 수 있다.  

3. 전략 패턴
> 자신의 기능 맥락(context)에서, 필요에 따라서 변경이 필요한 알고리즘을  
> 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를    
> 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴  

4. 제어의 역전(Inversion of Control)
> 제어권의 이전을 통한 제어관계 역전 - 프레임워크의 기본 동작 원리  
> 권한을 가지고 하던 작업이 다른 곳으로 넘어갔구나 -> 제어의 역전 (이렇게 이해해도 충분)  

* 스프링을 사용함으로써 얻게되는 장점이자 얻어야하는 목적
> 코드의 품질, 유지보수성을 높이고 잘 확장되면서도 불필요한 변경에는 닫혀있는 상태로 개발할 수 있게 하는 것  