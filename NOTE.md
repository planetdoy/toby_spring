# 강의 내용 정리

## 요구사항
- 해외직구를 위한 원화 결제 준비 기능 개발
- 주문번호, 외국 통화 종류, 외국 통화 기준 결제 금액을 전달 받아서 다음의 정보를 더해 Payment를 생성한다.
  - 적용환율
  - 원화 환산 금액
  - 원화 환산 금액 유효시간
- PaymentService.prepare() 메소드로 개발
  - Payment 오브젝트 리턴

## 개발 방법
- 빠르게 완성해서 가장 간단한 방법을 찾는다.
- 작성한 코드가 동작하는지 확인하는 방법을 찾는다.
- 조금씩 기능을 추가하고 다시 검증한다.
- 코드를 한눈에 이해하기 힘들다면 코멘트로 설명을 달아준다.
  - 3초 이내에 이해가 되지 않는다면 안티패턴일 수 있지만 이해가 되지 않는다면 달아두는게 좋고 해결하는 방법이 있다.

* Gradle
> JVM 환경에서 사용할 수 있는 범용적인 개발 도구  

* settings > gradle
> build 를 gradle 이 아닌 idea 로 변경하는게 좀더 빠르다.

* 돈 관련된 숫자 타입을 사용할 때는 BigDecimal 타입을 사용한다.

## 오브젝트와 의존관계
> 스프링에서 가장 중요한 용어들

### 오브젝트
> 오브젝트를 만들기 위해서 클래스를 작성한다.(청사진)
> 클래스의 인스턴스 = 오브젝트
> 인스턴스 - 추상적인 것(클래스)의 실체
> 자바에서는 배열(Array)도 오브젝트

### 의존관계
> 클래스 레벨의 의존관계, 런타임 레벨의 의존관계 
> Supplier 가 변경되면 Client 코드가 영향을 받는다.
> 하나의 클래스에서 다른 클래스를 사용하고 있다면 사용의존관계라고 이야기한다.

## 관심사의 분리(SoC)
> 관심사가 다른 건 분리해야한다.
> 기술적인 로직과 업무(비지니스)로직이 섞이면 코드를 이해하는데 어려움이 있을 수 있다.
> 관심사는 변경과 관련이 있다.
> 변경의 이유, 시점이 다른 코드를 같이 두는건 좋지 않다.
> 관심 분리 방법 1 - 메서드 추출
> 관심 분리 방법 2 - 클래스 추출
  > 재사용을 위해
  > 확장성을 위해
  > 상속 - 확장성 코드를 만들 때 사용할 수도 있다.
> "상속을 통한 확장"은 한계가 있다.

## 클래스의 분리 (TODO: 다시듣기)
> 상속을 통한 확장을 통해 필요한 메서드로 변경을 할 수 있었지만...

## 인터페이스의 도입
> 인터페이스를 생성하여 메서드를 선언하고 해당 메서드를 구현하는 클래스들을 작성함으로써 
> 최소한의 코드 변경으로 구현클래스를 변경할 수 있게 되었다.
> 그러나 여전히 결합도가 높은 상태이다. 여전히 비지니스 로직 클래스 파일을 수정해야하기 때문

## 관계설정 책임의 분리
> 런타임 의존관계, 코드레벨 의존관계
> 인터페이스의 도입으로 인터페이스에 의존하는 것 같지만 사실 인터페이스와 구현클래스 모두에 의존하고 있는 것 이다.
> 변경이 생기면 책임을 가진 곳도 변경이 일어나야합니다.
> 변경을 하지 않으려면 의존관계를 설정하는 부분을 분리시킨다.
> 분리방법은 변경되는 클래스 앞에 하나를 더 두고 의존관계를 전달하는 것이다.

## 오브젝트 팩토리
> 클래스 앞에서 의존관계를 전달 받았지만 전달하는 쪽(Client)에서도 
> 두가지 역할(1.의존관계 설정, 2.서비스로직 호출)을 맡게 되어 의존관계를 설정하는 클래스를 추가로 분리하였다.

## 원칙과 패턴
> 관심사의 분리로 코드를 변화를 해왔다.
> 객체지향 원칙
> 객체치향적 패턴

1. 개방 폐쇄 원칙(OCP) Open-Closed Principle
> 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다.  
> 어떤 부분은 열리고 어떤부분은 닫혀 있어야한다.  
> 정리 : 클래스의 기능을 확장할 때 클래스의 코드는 변경되면 안된다.  

2. 높은 응집도와 낮은 결합도
> 응집도가 높다는 것은 하나의 모듈이 하나의 책임 또는 관심사에 집중되어있다는 뜻.  
> 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.  

> 책임과 관심사가 다른 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.    
> 변화가 일어날 때 비용이 적게 든다.  
> 소프트웨어의 품질이 올라가고 높은 유지보수성을 가진다. 라고 이야기할 수 있다.  

3. 전략 패턴
> 자신의 기능 맥락(context)에서, 필요에 따라서 변경이 필요한 알고리즘을  
> 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를    
> 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴  

4. 제어의 역전(Inversion of Control)
> 제어권의 이전을 통한 제어관계 역전 - 프레임워크의 기본 동작 원리  
> 권한을 가지고 하던 작업이 다른 곳으로 넘어갔구나 -> 제어의 역전 (이렇게 이해해도 충분)  

* 스프링을 사용함으로써 얻게되는 장점이자 얻어야하는 목적
> 코드의 품질, 유지보수성을 높이고 잘 확장되면서도 불필요한 변경에는 닫혀있는 상태로 개발할 수 있게 하는 것  

## 스프링 컨테이너와 의존관계 주입(Dependency Injection)
> 스프링 = 스프링컨테이너
> IoC/DI 를 제공하는 컨테이너다.
> Bean 은 오브젝트라고 생각해도 되고 오브젝트중에서도 어플리케이션을 구성하고 있는 기능을 제공하고 담당하는 핵심 클래스의 오브젝트
> 컨테이너 : 오브젝트를 생성하여 가지고 있으며 하나의 오브젝트로 여러 쓰레드(사용자)가 사용 가능하여 성능저하를 막아준다.
> 추가로 만들어진 오브젝트 사이에 관계까지 설정해준다 해서 DI(IoC) 컨테이너라고 불린다.  

## 구성정보를 가져오는 다른 방법
> @Component 를 사용해서 @Bean으로 등록
> 빈은 자바의 컴포넌트 기술
> 빈 혹은 컴포넌트라고 부르기도 한다.
> @ - 메타프로그래밍 기법
> 스프링이 필요로 하는 것은 빈에 대한 정보이다.
> 빈의 정보를 전달하는 방법은 많다.

## 싱글톤 레지스트리(Singleton Registry)
> 스프링은 기본적으로 싱글톤 레지스트리로 동작하게 되어있다.
> 특별한 설정을 하지 않는다면 빈 오브젝트는 싱글톤으로 딱 한 개만 만든다.
> 스프링에서 빈 오브젝트는 싱글톤 레지스트리로 한 개만 만들어져서 여러 다른 오브젝트들에서 사용이 되더라도 동일한 오브젝트가 사용된다.

## DI와 디자인 패턴
> 1. Purpose
> 2. Scope
>   - Class : 상속
>   - Object : 합성 - 오브젝트 두개를 만들어서 런타임에 의존관계를 가지고 사용하게 만들자

> 캐시(Cache)의 도입
> 데코레이터(Decorator) 디자인패턴

## 의존성 역전 원칙(DIP)
> 1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
- 하위 수준의 모듈이 상위 수준의 모듈에 의존하도록 만들어라.
- 응집도가 높고 결합도가 낮은 것을 모듈이라고 이야기한다.
- jar 도 하나의 모듈이라고 할 수 있고 패키지로 잘 구분해둔 것들은 jar 로 분리를 할 수 있어서 모듈이라고 부를 수 있다.
- Policy Layer(정책, 비지니스)(상위), Mechanism(기술)(하위) Layer 로 나눌 수 있다.
- 추상화에 의존해야한다. -> 인터페이스에 의존하게 만든다.

> 2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

> 3. 인터페이스 소유권의 역전이 필요하다.
- Separated interface 패턴 
- 인터페이스는 어느 패키지에 들어있어야 하는가 라는 이야기 
- 인터페이스는 자기를 구현한 쪽이 아닌 사용하는 쪽에 있는 것이 자연스러운 경우가 많다.

## 섹션 3 : 테스트 (TEST)
### 자동으로 수행되는 테스트
> 수동 테스트의 한계  
  > 수동 확인은 불편하다.  
  > UI 까지 개발한 뒤 확인하는 방법은 테스트가 실패했을 때 확인할 코드가 많다.  
  > 테스트할 대상이 많아질 수록 검증하는데 시간이 많이 걸리고 부정확함  

> 작은 크기의 자동으로 수행되는 테스트  

> 개발자가 만드는 테스트  
  > 개발한 코드에 대한 검증 기능을 코드로 작성한다.  
  > 자동으로 테스트를 수행하고 결과를 확인하다.  
  > 테스팅 프레임워크를 활용한다.  
  > 테스트 작성과 실행도 개발 과정의 일부이다.  

### JUnit 테스트 작성
> JUnit 5  
> - @Test 테스트 메소드  
> - @BeforeEach 테스트   
>   - 각 테스트 전에 실행된다.